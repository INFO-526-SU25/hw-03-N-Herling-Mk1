---
title: "HW 03"
author: "Nathan Herling"
date: "2025-06-20"
_due: "Friday-June-13-2025"   
format:
  html:
    embed-resources: true
    code-fold: true
    code-tools: true
    toc: true
    css: styles.css       # ✅ Add this line to link your CSS file
---

```{r setup}
#--------------------->
#################
# Package Setup #
#################
#Check if pacman [package manager] is installed, if not install it.
#throw [FYI] alert either way.
if (!requireNamespace("pacman", quietly = TRUE)) {
  message("Installing 'pacman' (not found locally)...")
  install.packages("pacman")
} else {
  message("[FYI]\n'pacman' already installed — skipping install.")
}
# use this line for installing/loading
# pacman::p_load()
# - packages to load stored in a variable (vector)
pkgs <- c(
  "tidyverse",
  "glue",
  "scales",
  "lubridate",
  "patchwork",
  "ggh4x",
  "ggrepel",
  "openintro",
  "ggridges",
  "dsbox",
  "janitor",
  "here",
  "knitr",
  "ggthemes",
  "ggplot2",
  "kableExtra",
  "palmerpenguins",
  "grid",
  "htmltools",
  "plotly",
  "ggforce",
  "cowplot",
  "magick",
  "forcats",
  "stringr"
)
# - load from the character array/vector
pacman::p_load(char=pkgs)

# - install tidyverse/dsbox directly from Git Hub
# - this allows for the possible need to install on a repo. pull.
# - and, if it's already installed just thorw an alert.
if (!requireNamespace("dsbox", quietly = TRUE)) {
  message("Installing 'dsbox' from GitHub (not found locally)...")
  suppressMessages(devtools::install_github("tidyverse/dsbox"))
} else {
  message("[FYI]\n'dsbox' already installed — skipping GitHub install.")
}

# - alert to user packages loaded.
# Set number of columns (adjustable)
n_cols <- 4

# Add * to each package name
pkgs <- paste0("* ", pkgs)

# Calculate number of rows based on total packages
n_rows <- ceiling(length(pkgs) / n_cols)

# Pad with empty strings to complete grid
pkgs_padded <- c(pkgs, rep("", n_rows * n_cols - length(pkgs)))

# Create matrix (fill by row)
pkg_matrix <- matrix(pkgs_padded, nrow = n_rows, byrow = TRUE)

# Print header
cat("The packages loaded:")

# Loop and print each row (use invisible to suppress NULL)
invisible(apply(pkg_matrix, 1, function(row) {
  cat(paste(format(row, width = 22), collapse = ""), "\n")
}))
#-------------------------->
######################
# Basic set Theme up #
######################
# ---- set theme for ggplot2
ggplot2::theme_set(ggplot2::theme_minimal(base_size = 14))

# set width of code output
options(width = 65)

# set figure parameters for knitr
knitr::opts_chunk$set(
  fig.width = 7,        # 7" width
  fig.asp = 0.618,      # the golden ratio
  fig.retina = 3,       # dpi multiplier for displaying HTML output on retina
  fig.align = "center", # center align figures
  dpi = 300             # higher dpi, sharper image
)
## ---- end theme set up
```


## 1 - Du Bois challenge.
<div class="question-box">
Du Bois challenge. Recreate the following visualization by W.E.B. Du Bois on family budgets split by income classes for 150 families in Atlanta, Georgia. This visualization was originally created using ink and watercolors.
</div>

<div class="note-box">
Note: Since there appears to be some allowable creativity with the features reperesented.
I left a scale on the bottom of the parchment, and left off the 'connecting lines' connecting the same colored segments together for the stacked bar charts.
It ended up being a lot of code - to separately construct and place all pieces of the chart together.
First effort. There may be a more efficient way to re-make the plot?
.
I rendered the output image as html - and I cannot git rid of the small 'png 2' label (atm).
</div>


```{r,fig.width=12, fig.height=8, out.width="95%",create_image, fig.cap=""}
#| label: label-me-1
#| echo: false
#| results: asis


# Load the data
income_data <- read_csv("data/income.csv", show_col_types = FALSE)

# --- New: Extract data for col_0, row_1..5 overlay table ---
table_data <- income_data |>
  select(Class, `Actual Average` = Average_Income) |>
  mutate(`Actual Average` = dollar(`Actual Average`))  # Format as US Dollars

# Add header row
header_row <- tibble(Class = "Class", `Actual Average` = "ACTUAL AVERAGE")
table_data <- bind_rows(header_row, table_data)

# Load parchment image
invisible(background_img <- image_read("images/parchment_sheet.png"))

#- Get image dimensions ... for initial examination of how large the background image is.
invisible(info <- image_info(background_img))
img_width <- info$width
img_height <- info$height

# Margins and title height
margin <- 40
title_height <- 100
gap_below_title <- -50

# Create transparent canvas for the title text
title_canvas <- image_blank(width = img_width, height = title_height + margin, color = "none")

# Annotate the title
title_text <- "INCOME AND EXPENDITURE OF 150 NEGRO FAMILIES IN ATLANTA,GA.,USA."
title_layer <- image_annotate(
  title_canvas,
  text = title_text,
  size = 25,
  gravity = "north",
  location = "+0+40",
  font = "IM FELL English SC",
  weight = 700,
  color = "#000000BB"
)

title_layer <- image_blur(title_layer, radius = 0.5, sigma = 0.3)
composite_img <- image_composite(background_img, title_layer, offset = "+0+0")

# Compute usable space for grid below title
usable_width <- img_width - 2 * margin
usable_height <- img_height - margin - title_height
n_cols <- 6
n_rows <- 4
cell_width <- usable_width / n_cols
cell_height <- usable_height / n_rows

# Grid positions
grid_top <- margin + title_height + gap_below_title
grid_bottom <- img_height - margin
grid_left <- margin
grid_right <- img_width - margin

# Read and resize image to fit cell (0,0)
annual_income_img <- image_read("images/annual_income.png")
annual_income_img_resized <- image_scale(annual_income_img, geometry = paste0(cell_width, "x", cell_height, "!"))
x_pos <- grid_left
y_pos <- grid_top
composite_img <- image_composite(composite_img, annual_income_img_resized, offset = paste0("+", x_pos, "+", y_pos))

# Add label with border across cols 1 to 5
span_x_left <- grid_left + cell_width * 1
span_x_right <- grid_left + cell_width * 6
span_width <- span_x_right - span_x_left

label_text <- image_blank(width = span_width, height = 50, color = "none")
label_text <- image_annotate(
  label_text,
  text = "ANNUAL EXPENDITURE FOR",
  size = 25,
  gravity = "center",
  font = "IM FELL English SC",
  weight = 0,
  color = "#000000BB"
)

label_trimmed <- image_trim(label_text)
label_padded <- image_extent(label_trimmed, geometry = paste0(span_width, "x", image_info(label_trimmed)$height), gravity = "center")
label_with_border <- image_border(label_padded, color = "black", geometry = "2x2")
label_height <- image_info(label_with_border)$height
label_y <- grid_top - label_height + 2
label_x <- span_x_left

composite_img <- image_composite(
  composite_img,
  label_with_border,
  offset = paste0("+", round(label_x), "+", round(label_y))
)


#========
# Add column titles (RENT, FOOD, etc.)
top_col_titles <- c("RENT", "FOOD", "CLOTHES", "DIRECT TAXES", "OTHER EXPENSES AND SAVINGS")

title_height_area <- 15  # uniform height for all title boxes

for (i in 1:5) {
  title_x_left <- grid_left + (i * cell_width)
  title_width <- cell_width

  # Estimate font size to fit the column width
  max_text_width <- title_width - 10  # padding
  title_font_size <- 25
  title_box_temp <- image_blank(width = title_width, height = title_height_area, color = "none")

  repeat {
    title_test <- image_annotate(
      title_box_temp,
      text = top_col_titles[i],
      size = title_font_size,
      gravity = "center",
      font = "Broadway",
      weight = 0,
      color = "#000000BB"
    )
    if (image_info(title_test)$width <= max_text_width || title_font_size <= 9.5) break
    title_font_size <- title_font_size - 1
  }

  title_box <- image_blank(width = title_width, height = title_height_area, color = "none")
  title_annotated <- image_annotate(
    title_box,
    text = top_col_titles[i],
    size = title_font_size,
    gravity = "center",
    font = "IM FELL English SC",
    weight = 0,
    color = "#000000BB"
  )

  title_with_border <- image_border(title_annotated, color = "black", geometry = "2x2")

  title_y <- grid_top - title_height_area + 15
  title_x <- title_x_left

  composite_img <- image_composite(
    composite_img,
    title_with_border,
    offset = paste0("+", round(title_x), "+", round(title_y))
  )
}

# --- NEW: Add image icons below headers and above footers ---
images_col_headers <- c(
  "images/rent.jpg",
  "images/food.png",
  "images/clothes.png",
  "images/direct_taxes.png",
  "images/other_expenses_savings.png"
)

icon_height <- 132
icon_gap_top <- 3
icon_gap_bottom <- 3

for (i in 1:5) {
  icon_x_left <- grid_left + (i * cell_width)
  icon_width <- cell_width
  icon_y <- grid_top + title_height_area + icon_gap_top

  icon_img <- image_read(images_col_headers[i])
  icon_resized <- image_scale(icon_img, geometry = paste0(icon_width, "x", icon_height, "!"))
  icon_with_border <- image_border(icon_resized, color = "black", geometry = "2x2")

  composite_img <- image_composite(
    composite_img,
    icon_with_border,
    offset = paste0("+", round(icon_x_left), "+", round(icon_y))
  )
}

# --- Restore column footers with colors for columns 1 to 5 ---
c_palette <- c("#1B1B19",
               "#755D75",
               "#C18C7E",
               "#ab9f9d",
               "#d9e6e8"
)

footer_height_area <- title_height_area

for (i in 1:5) {
  footer_x_left <- grid_left + (i * cell_width)
  footer_width <- cell_width

  footer_box <- image_blank(width = footer_width, height = footer_height_area, color = c_palette[i])
  footer_with_border <- image_border(footer_box, color = "black", geometry = "2x2")

  footer_y <- grid_top + cell_height - footer_height_area - 4
  footer_x <- footer_x_left

  composite_img <- image_composite(
    composite_img,
    footer_with_border,
    offset = paste0("+", round(footer_x), "+", round(footer_y))
  )
}
#=====--------------------------------------------------------------------->>> checked
#============== LEFT COLUMN TABLE ==================================>>>
# --- NEW: Render table in col_0, rows 0 to 6 (header + 6 rows) ---
# --- UPDATED: Render table spanning from row_1 to row_5 (entire vertical height of 4 grid rows) ---
library(stringr)  # make sure stringr is loaded

# Add horizontal scale factor (e.g., 0.85 means 85% width)
horizontal_scale <- 0.91
col_width <- (cell_width / 2) * horizontal_scale  # Scaled column width

cell_x <- grid_left
num_rows <- nrow(table_data)

table_top_y <- grid_top + cell_height + 5      # start at row_1 - manually adjust height(s)
table_total_height <- 4 * cell_height          # span rows 1 to 5 (4 grid rows)

header_row_height <- 20                        # smaller height for header
data_rows_height <- table_total_height - header_row_height
data_row_height <- data_rows_height / (num_rows - 1) - 25  # divide remaining height among data rows

# Define wrap width — adjust based on your cell width and font size
wrap_width <- 10

# Render header row
row_y <- table_top_y

# Wrap the header cell text (Class)
class_text_wrapped <- str_wrap(table_data$Class[1], width = wrap_width)

class_box <- image_blank(width = col_width, height = header_row_height, color = "none")
class_box <- image_annotate(
  class_box,
  text = class_text_wrapped,
  size = 9,
  gravity = "center",
  font = "IM FELL English SC",
  weight = 300,
  color = "#000000DD"
)
class_box_bordered <- image_border(class_box, color = "black", geometry = "1x1")

# income header as before
income_box <- image_blank(width = col_width, height = header_row_height, color = "none")
income_box <- image_annotate(
  income_box,
  text = table_data$`Actual Average`[1],
  size = 7.5,
  gravity = "center",
  font = "IM FELL English SC",
  weight = 300,
  color = "#000000DD"
)
income_box_bordered <- image_border(income_box, color = "black", geometry = "1x1")

composite_img <- image_composite(composite_img, class_box_bordered, offset = paste0("+", cell_x, "+", round(row_y)))
composite_img <- image_composite(composite_img, income_box_bordered, offset = paste0("+", cell_x + col_width, "+", round(row_y)))

row_y <- row_y + header_row_height

# Render data rows with pale brownish background
for (i in 2:num_rows) {
  bg_col <- ifelse(i %% 2 == 0, "#E3D6BD99", "#FFFFFF00")
  class_bg <- image_blank(width = col_width, height = data_row_height, color = bg_col)
  income_bg <- image_blank(width = col_width, height = data_row_height, color = bg_col)

  # Wrap class cell text here
  class_text_wrapped <- str_wrap(table_data$Class[i], width = wrap_width)

  class_cell <- image_annotate(
    class_bg,
    text = class_text_wrapped,
    size = 9,
    gravity = "center",
    font = "IM FELL English SC",
    weight = 300,
    color = "#000000DD"
  )
  income_cell <- image_annotate(
    income_bg,
    text = table_data$`Actual Average`[i],
    size = 9,
    gravity = "center",
    font = "IM FELL English SC",
    weight = 300,
    color = "#000000DD"
  )

  class_cell_bordered <- image_border(class_cell, color = "black", geometry = "1x1")
  income_cell_bordered <- image_border(income_cell, color = "black", geometry = "1x1")

  composite_img <- image_composite(composite_img, class_cell_bordered, offset = paste0("+", cell_x, "+", round(row_y)))
  composite_img <- image_composite(composite_img, income_cell_bordered, offset = paste0("+", cell_x + col_width, "+", round(row_y)))

  row_y <- row_y + data_row_height
}

#============== BAR CHART OVERLAY WITH CONTROLS ===============================>>>
# --- Adjustable Variables ---
bar_chart_height_scale <- 0.75    # Controls vertical compression of bar chart (0 to 1)
bar_spacing_ratio      <- 0.7     # Controls thickness of bars (height of each bar)
bar_chart_offset_x     <- 0       # Horizontal adjustment in pixels
bar_chart_offset_y     <- 5       # Vertical adjustment in pixels
bar_gap_size           <- 1       # Controls vertical spacing between bar groups (not used now)

# --- Data Prep ---
income_long <- income_data %>%
  pivot_longer(cols = c("Rent", "Food", "Clothes", "Tax", "Other"),
               names_to = "name", values_to = "value") %>%
  filter(!is.na(value), value != 0) %>%
  mutate(name = toupper(name)) %>%
  mutate(textcol = ifelse(name == "RENT", "1", "0"))

# --- Create spacer factor levels between Classes ---
classes <- rev(unique(income_data$Class))  # Reversed order for top-to-bottom inversion
spacer_levels <- paste0("SPACER_", seq_len(length(classes) - 1))

# Interleave classes and spacer_levels manually
new_levels <- character(length(classes) + length(spacer_levels))
new_levels[c(TRUE, FALSE)] <- classes
new_levels[c(FALSE, TRUE)] <- spacer_levels

# Assign Class_spaced with original classes first
income_long <- income_long %>%
  mutate(Class_spaced = factor(as.character(Class), levels = classes))

# Create spacer rows with zero value for each spacer level
spacer_rows <- data.frame(
  Class_spaced = factor(spacer_levels, levels = new_levels),
  name = "SPACER",
  value = 0,
  textcol = "0"
)

income_augmented <- bind_rows(income_long, spacer_rows) %>%
  mutate(Class_spaced = factor(as.character(Class_spaced), levels = new_levels)) %>%
  arrange(Class_spaced, name != "SPACER")

# Prepare a helper dataset for connectors
stack_order <- c("OTHER", "TAX", "CLOTHES", "FOOD", "RENT")

connector_data <- income_augmented %>%
  filter(name != "SPACER") %>%
  mutate(name = factor(name, levels = stack_order)) %>%
  group_by(name) %>%
  mutate(group_index = row_number()) %>%
  ungroup()

# Build the plot
income_plot <- ggplot(income_augmented, aes(
  x = Class_spaced,
  y = value,
  fill = factor(name, levels = stack_order),
  label = paste0(formatC(value, format = "f", digits = 1), "%")
)) +
  geom_bar(
    stat = "identity",
    position = "stack",
    width = bar_spacing_ratio,
    color = NA,
    linewidth = 0.2
  ) +
  geom_text(
    data = subset(income_augmented, name != "SPACER"),
    aes(color = textcol),
    position = position_stack(vjust = 0.5),
    size = 3,
    show.legend = FALSE
  ) +
  coord_flip() +
  scale_x_discrete(expand = expansion(add = c(0.5, 0.5))) +
  theme(
    legend.position = "none",
    plot.margin = margin(20 + bar_chart_offset_y, 40 + bar_chart_offset_x, 0, 20),
    plot.background = element_rect(fill = NA, color = NA),
    panel.background = element_rect(fill = NA, color = NA),
    legend.background = element_rect(fill = NA),
    legend.key = element_rect(fill = NA),
    axis.title = element_blank(),
    text = element_text(family = "mono"),
    axis.ticks = element_blank(),
    axis.line = element_blank(),
    panel.border = element_blank(),
    axis.text.y = element_blank(),
    plot.title = element_blank(),
    panel.grid = element_blank()
  ) +
  scale_fill_manual(values = c("#cbdfbd", "#8e9aaf", "#d78879", "#a08294", "#161213")) +
  scale_color_manual(values = c("black", "white")) +
  labs(fill = "", x = "", y = "")



# --- Render and Position Chart ---
temp_file <- tempfile(fileext = ".png")
ggsave(filename = temp_file, plot = income_plot, width = 8, height = 5, dpi = 144, bg = "transparent")
bar_chart_img <- image_read(temp_file)

bar_chart_width <- cell_width * 5.5
bar_chart_height <- cell_height * 4 * bar_chart_height_scale  # Scale height

bar_chart_resized <- image_scale(bar_chart_img, paste0(bar_chart_width, "x", bar_chart_height, "!"))

bar_chart_x <- grid_left + cell_width + bar_chart_offset_x - 50
bar_chart_y <- grid_top + cell_height + bar_chart_offset_y
#====================================================
composite_img <- image_composite(
  composite_img,
  bar_chart_resized,
  offset = paste0("+", round(bar_chart_x), "+", round(bar_chart_y))
)
# === Add Right-Side Vertical Class Labels ===

# Define the labels and how many bar rows they span
right_labels <- c("POOR", "FAIR", "COMFORTABLE", "WELL-TO-DO")
row_counts   <- c(2, 2, 2, 1)

# Total rows = 7 actual class rows (no spacers included)
total_rows <- sum(row_counts)

# Compute height per row (based on the bar chart height)
row_height <- bar_chart_height / total_rows

# Starting Y for the bottom-most label
label_start_y <- bar_chart_y

# Label X position (to the right of bar chart)
label_x <- bar_chart_x + bar_chart_width - 150  # Add padding

shift_down_pixels <- 10  # adjust as you want (positive = move down)

# -
for (i in seq_along(right_labels)) {
  label_text <- right_labels[i]
  rows_span <- row_counts[i]
  label_height <- row_height * rows_span
  label_y <- 5 + label_start_y + (row_height * (sum(row_counts[1:(i-1)]))) + (label_height / 2)

  # Move POOR up 2 rows (your existing adjustment)
  if (label_text == "POOR") {
    label_y <- label_y - 2 * row_height
  }

  # NEW: move POOR and FAIR *down* by shift_down_pixels
  if (label_text %in% c("POOR", "FAIR")) {
    label_y <- label_y + shift_down_pixels
  }

  # Create and annotate image
  label_img <- image_blank(width = 30, height = label_height, color = "none")
  label_img <- image_annotate(
    label_img,
    text = label_text,
    size = 11,
    gravity = "center",
    font = "IM FELL English SC",
    weight = 300,
    color = "#000000DD",
    degrees = 270  # Vertical text (bottom to top)
  )
  #label_img <- image_trim(label_img)  # <-- removes padding
  # ➕ Create brace image
  brace_img <- image_blank(width = 40, height = label_height, color = "none")
  brace_img <- image_annotate(
    brace_img,
    text = "}",  # curly brace
    size = label_height * 0.9,  # scale size to span rows
    gravity = "center",
    font = "Times",  # or another serif font with a clear brace
    color = "#000000AA"
  )

  # ➕ Combine brace and label horizontally
  combined_img <- image_append(c(brace_img, label_img))

  # 🧷 Composite onto final image
  composite_img <- image_composite(
    composite_img,
    combined_img,
    offset = paste0("+", round(label_x+70), "+", round(label_y - label_height / 2))
  )
}

#======================================>>>>
# Draw the grid and requested horizontal lines inside the left table
final_img <- image_draw(composite_img)

# Thickness of cell border lines (in pixels)
line_thickness <- 1

# x positions: start and end of left table (two columns combined)
x_start <- cell_x
x_end <- cell_x + 2.8 * col_width

# y positions for horizontal lines, adjustable for rows 1 to 7
y_positions <- numeric(8)  # 7 rows + header

# row_1 (header row top)
y_positions[1] <- table_top_y

# row_2 to row_8 (header + 7 rows total)
for (r in 2:8) {
  if (r == 2) {
    y_positions[r] <- table_top_y + header_row_height
  } else {
    y_positions[r] <- y_positions[r - 1] + data_row_height
  }
}

# Draw thin black horizontal arrows at each row boundary (except header)
for (y in y_positions[-1]) {
  arrows(
    x0 = x_start, y0 = y,
    x1 = x_end,   y1 = y,
    col = "black",
    lwd = line_thickness,
    length = 0.08,
    angle = 20,
    code = 2
  )
}

# Add one extra arrow extending off the edge under last data row
y_adjust <- 69
arrows(
  x0 = cell_x + 2 * col_width,
  y0 = y_positions[8] + y_adjust,
  x1 = cell_x + 3 * col_width - 15,
  y1 = y_positions[8] + y_adjust,
  col = "black",
  lwd = line_thickness,
  length = 0.08,
  angle = 20,
  code = 2
)

dev.off()  # finish image_draw and save to final_img

# Replace composite_img with final_img (arrows added)
composite_img <- final_img


#=========== OUTPUT FILE ============
# Write output
invisible(image_write(composite_img, path = "output/final_composite.png"))
invisible()

# Optionally display the image
#print(composite_img)
# Embed it explicitly into HTML
cat('<img src="output/final_composite.png" style="width:100%;">')
#knitr::include_graphics("output/final_composite.png")

```

## 2 - COVID survey - interpretation

<div class="question-box">
Q2 - <b>Interpret what’s occurring in the survey, and discuss any results that go against your intuition.</b> <br>In a chart this large, <i>“interpret”</i> (as opposed to simply describing) really means identifying trends in the data.
<br>
<b>1. <i>Trust and Profession:</i></b> <br>Medical students showed noticeably more variance in agreement (i.e. a broader distribution of Likert scores) than nursing students with the statement “I trust the information that I have received about the vaccines.” This could be interpreted as a difference in behavior/diagnostic techniques between the two professions.
<br>
<b>2. <i>Concern and Age:</i></b> <br>Of note was the general ambivalence towards <i>'safety and side effects'</i>, as represented by the average score of '3' across all age groups. While the distribution was wide for all age groups, the general consensus among those in the medical profession was no concern for the safety involved with the vaccine.
<br>
<b>3. <i>Vaccination History and Vaccine Perception:</i></b> <br>Across the board - high <i>'strongly agree'</i> - to the category of 'I will recommend the vaccine to family, friends, and community members.' This would show a very strong trend of trusting the science in the medical community.

<b>4. <i>Counter intuitive/interesting</i></b><br>
One interesting trend was that responses by gender identity showed subtle but noteworthy divergence. For some response variables—especially those touching on vaccine efficacy or side effects—nonbinary respondents’ scores tended to fall at the extremes, reflecting either more trust or more concern.

Another pattern emerged in the age dimension, with younger respondents appearing to show greater trust in vaccines.

Overall, it's striking that the medical and nursing student community was not in lockstep regarding their interpretations of the science and its safety.
</div>

```{r}
#| label: label-me-2
#------- no code necessary ..

```

## 3 - COVID survey - reconstruct
<div class="question-box">
Q3 ....
</div>
<details>

<summary>Data Analysis - Q1</summary>
```{r}
#| label: label-me-3_data_table
#| echo: false
#| fig-asp: 0.63
#| fig-width: 7
#| 
#===========
# Question 3
#===========

# Step 1: Read CSV without headers to inspect structure
# - Define "" and "NA" as missing
raw_preview <- read_csv(
  "data/covid-survey.csv",
  col_names = FALSE,
  na = c("", "NA"),
  show_col_types = FALSE
)

# Step 2: View to determine the row containing real column names
View(raw_preview)

# Step 3: Based on inspection, set the correct `skip` value
# (assume row 2 is the real header → skip = 1)
survey_raw <- read_csv(
  "data/covid-survey.csv",
  skip = 1,
  na = c("", "NA"),
  show_col_types = FALSE
)

# Step 4: Dynamically get column names
col_names <- names(survey_raw)

# =====================
# Diagnostic Summary
# =====================

# - Overall % missing values (NA)
total_cells <- nrow(survey_raw) * ncol(survey_raw)
missing_cells <- sum(is.na(survey_raw))
missing_pct_total <- round(100 * missing_cells / total_cells, 2)

# - % of rows with at least one NA
rows_with_na <- survey_raw |> filter(if_any(everything(), is.na))
pct_rows_with_na <- round(100 * nrow(rows_with_na) / nrow(survey_raw), 2)
row_indices_with_na <- which(apply(survey_raw, 1, function(x) any(is.na(x))))

# - Rows with more than one NA
na_per_row <- survey_raw |> apply(1, function(x) sum(is.na(x)))
rows_with_multiple_na <- which(na_per_row > 1)
pct_rows_with_multiple_na <- round(100 * length(rows_with_multiple_na) / nrow(survey_raw), 2)

# - Create diagnostic summary table
dataset_diagnostics <- tibble(
  Metric = c(
    "Total % of values missing",
    "Percent of rows with ≥1 NA",
    "Row indices with ≥1 NA (first 20)",
    "Percent of rows with >1 NA",
    "Row indices with >1 NA (first 20)"
  ),
  Value = c(
    missing_pct_total,
    pct_rows_with_na,
    paste(head(row_indices_with_na, 20), collapse = ", "),
    pct_rows_with_multiple_na,
    paste(head(rows_with_multiple_na, 20), collapse = ", ")
  )
)

# ==============================
# Quarto-Ready Diagnostic Table
# ==============================

library(kableExtra)

dataset_diagnostics |>
  kable(
    caption = "<span style='font-weight:bold; font-size:1.1em;'>Table 1. Dataset Missing Value Diagnostics</span>",
    escape = FALSE
  ) |>
  kable_styling(
    full_width = FALSE,
    bootstrap_options = c("striped", "hover", "condensed")
  ) |>
  row_spec(
    which(dataset_diagnostics$Metric == "Total % of values missing"),
    background = "#fff3cd"  # Light highlight
  )

# =======================================
# Remove rows with any NA values
# =======================================

# - Original dataset row count
original_row_count <- nrow(survey_raw)

# - Create new tibble with complete cases only
survey_clean <- survey_raw |> filter(if_all(everything(), ~ !is.na(.x)))

# - Number of rows removed
rows_removed <- original_row_count - nrow(survey_clean)

# - User alert with clear summary
cat(
  glue::glue(
    "✅ Rows with at least one NA have been removed.\n",
    "Original dataset rows: {original_row_count}\n",
    "Rows removed: {rows_removed}\n",
    "Cleaned dataset size: {nrow(survey_clean)} rows × {ncol(survey_clean)} columns\n"
  )
)

# - Print cleaned data frame dimensions (optional redundancy)
print(dim(survey_clean))

# - Optional: Preview cleaned data (first 5 rows)
#print(head(survey_clean, 5))


```
</details>



```{r}
#| label: label-me-3

```

## 4 - COVID survey - re-reconstruct
<div class="question-box">
Q4 ....
</div>
```{r}
#| label: label-me-4

```

## 5 - COVID survey - another view
<div class="question-box">
Q5 ....
</div>
```{r}
#| label: label-me-5

```
